<?php

namespace App\Services;

use App\Models\Chat;
use App\Models\ChatMessage;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;

class NL2SQLService
{
	public function __construct(
		private readonly SchemaSnapshot $schemaSnapshot,
		private readonly OpenAIService $openAI,
		private readonly SQLGuard $sqlGuard,
	) {}

	public function handleUserMessage(Chat $chat, ChatMessage $message): array
	{
		$maxTokens = (int)config('nl2sql.max_tokens', 8000);
		$maxRows = (int)config('nl2sql.max_rows', 200);

		$schema = $this->schemaSnapshot->build($maxTokens);
		
		// Debug: Log the schema being sent to AI
		Log::info('Schema being sent to OpenAI:', ['schema_length' => strlen($schema), 'schema_preview' => substr($schema, 0, 500)]);
		
		$history = $chat->messages()->latest()->take(10)->get()->reverse();
		$historyText = '';
		foreach ($history as $m) {
			$role = strtoupper($m->role);
			$historyText .= "{$role}: {$m->content}\n";
		}

		$prompt = <<<PROMPT
You are to produce ONE safe, read-only SQL statement for MySQL.
Constraints:
- Allowed verbs: SELECT, SHOW, DESCRIBE, EXPLAIN.
- No mutations, no multiple statements, no dangerous functions, no comments.
- Prefer simple joins and explicit columns. If aggregating, alias columns clearly.
- If no LIMIT is provided, add LIMIT {$maxRows}.
- CRITICAL: Use EXACT table names as shown in the schema below. Do not guess or abbreviate table names.
- If you need sales data, use 'sales_receipts' table, not 'sales'.
- If you need inventory data, use 'inventory_general' table, not 'inventory'.
- Always verify table names exist in the schema before using them.
- Do NOT use CREATE (including CREATE TEMPORARY TABLE or CREATE VIEW), DROP, INSERT, UPDATE, DELETE, REPLACE, TRUNCATE, ALTER, GRANT, REVOKE, SET, or file I/O (INFILE/OUTFILE/LOAD_FILE).
- If you need intermediate results, use subqueries, joins, or a CTE (WITH ...) within a single SELECT.

Database schema (compact):
{$schema}

Chat context:
{$historyText}

User request:
{$message->content}

Return only SQL. No markdown, no explanation.
PROMPT;

		try {
			$sql = $this->openAI->generateSql($prompt);
			
			// Debug: Log the SQL generated by AI
			Log::info('SQL generated by OpenAI:', ['sql' => $sql]);
			
			$sql = $this->sqlGuard->sanitize($sql);
			
			// Debug: Log the sanitized SQL
			Log::info('Sanitized SQL:', ['sql' => $sql]);

			// Validate schema usage before execution
			$this->validateSchema($sql);

			$result = $this->executeWithTimeout($sql, 15);

			$message->sql = $sql;
			$message->result = $this->truncateResult($result, $maxRows);
			$message->save();

			return ['ok' => true, 'sql' => $sql, 'rows' => $message->result];
		} catch (\Throwable $e) {
			$message->sql = $message->sql ?? null;
			$message->error = $e->getMessage();
			$message->save();
			return ['ok' => false, 'error' => $e->getMessage(), 'sql' => $message->sql];
		}
	}

	private function executeWithTimeout(string $sql, int $seconds): array
	{
		$seconds = max(1, min(60, $seconds));
		$driver = config('database.default');
		
		// Only set timeout for MySQL/MariaDB if the variable is supported
		if (in_array(config("database.connections.$driver.driver"), ['mysql','mariadb'], true)) {
			try {
				// Check if MAX_EXECUTION_TIME is supported
				DB::statement('SET SESSION MAX_EXECUTION_TIME = ?', [$seconds * 1000]);
			} catch (\Exception $e) {
				// If MAX_EXECUTION_TIME is not supported, just log it and continue
				Log::info('MAX_EXECUTION_TIME not supported, continuing without timeout setting');
			}
		}
		
		return DB::select($sql);
	}

	private function truncateResult(array $rows, int $maxRows): array
	{
		if (count($rows) <= $maxRows) return $rows;
		return array_slice($rows, 0, $maxRows);
	}

	private function validateSchema(string $sql): void
	{
		try {
			// Use EXPLAIN to validate tables/columns without executing the query
			DB::select('EXPLAIN ' . $sql);
			return;
		} catch (\Throwable $e) {
			$message = $e->getMessage();
			// Attempt to detect unknown table/column patterns
			$unknownTable = null;
			$unknownColumn = null;
			if (preg_match('/Table\s+\'([^\']+)\'\s+doesn\'t\s+exist/i', $message, $m)) {
				$unknownTable = $m[1];
			} elseif (preg_match('/Unknown\s+column\s+\'([^\']+)\'/i', $message, $m)) {
				$unknownColumn = $m[1];
			}

			if ($unknownTable) {
				$this->throwWithTableSuggestions($unknownTable, $message);
			}
			if ($unknownColumn) {
				$this->throwWithColumnSuggestions($unknownColumn, $sql, $message);
			}
			// Re-throw if we couldn't parse for suggestions
			throw $e;
		}
	}

	private function throwWithTableSuggestions(string $unknownTable, string $originalMessage): void
	{
		$connection = config('database.default');
		$database = config("database.connections.$connection.database");
		$rows = DB::select(
			"SELECT TABLE_NAME FROM information_schema.TABLES WHERE TABLE_SCHEMA = ? ORDER BY TABLE_NAME",
			[$database]
		);
		$tables = array_map(fn($r) => $r->TABLE_NAME, $rows);
		$suggestions = $this->closestMatches($unknownTable, $tables);
		$hint = empty($suggestions) ? '' : (' Suggestions: ' . implode(', ', array_slice($suggestions, 0, 5)) . '.');
		throw new \InvalidArgumentException("Unknown table '$unknownTable'." . $hint);
	}

	private function throwWithColumnSuggestions(string $unknownColumn, string $sql, string $originalMessage): void
	{
		$connection = config('database.default');
		$database = config("database.connections.$connection.database");
		// Try to infer table names referenced in the SQL
		$tables = $this->extractTableCandidates($sql);
		$columnMap = [];
		foreach ($tables as $t) {
			$cols = DB::select(
				"SELECT COLUMN_NAME FROM information_schema.COLUMNS WHERE TABLE_SCHEMA = ? AND TABLE_NAME = ?",
				[$database, $t]
			);
			$columnMap[$t] = array_map(fn($r) => $r->COLUMN_NAME, $cols);
		}
		$allColumns = array_values(array_unique(array_merge(...array_values($columnMap) ?: [[]])));
		$suggestions = $this->closestMatches($unknownColumn, $allColumns);
		$hint = empty($suggestions) ? '' : (' Did you mean: ' . implode(', ', array_slice($suggestions, 0, 5)) . '?');
		throw new \InvalidArgumentException("Unknown column '$unknownColumn'." . $hint);
	}

	private function extractTableCandidates(string $sql): array
	{
		$matches = [];
		$tables = [];
		if (preg_match_all('/\bFROM\s+([`\w\.]+)/i', $sql, $matches)) {
			$tables = array_merge($tables, array_map(fn($s) => trim($s, '`'), $matches[1]));
		}
		if (preg_match_all('/\bJOIN\s+([`\w\.]+)/i', $sql, $matches)) {
			$tables = array_merge($tables, array_map(fn($s) => trim($s, '`'), $matches[1]));
		}
		return array_values(array_unique($tables));
	}

	private function closestMatches(string $needle, array $haystack): array
	{
		$scored = [];
		foreach ($haystack as $item) {
			$scored[$item] = levenshtein(strtolower($needle), strtolower($item));
		}
		asort($scored);
		return array_keys(array_slice($scored, 0, 5, true));
	}
}
