<?php

namespace App\Services;

use App\Models\Chat;
use App\Models\ChatMessage;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;

class NL2SQLService
{
	public function __construct(
		private readonly SchemaSnapshot $schemaSnapshot,
		private readonly OpenAIService $openAI,
		private readonly SQLGuard $sqlGuard,
	) {}

	public function handleUserMessage(Chat $chat, ChatMessage $message): array
	{
		$maxTokens = (int)config('nl2sql.max_tokens', 8000);
		$maxRows = (int)config('nl2sql.max_rows', 200);

		$schema = $this->schemaSnapshot->build($maxTokens);
		
		// Debug: Log the schema being sent to AI
		Log::info('Schema being sent to OpenAI:', ['schema_length' => strlen($schema), 'schema_preview' => substr($schema, 0, 500)]);
		
		$history = $chat->messages()->latest()->take(10)->get()->reverse();
		$entityHints = $this->resolveEntitiesFromHistory($history);
		$historyText = '';
		foreach ($history as $m) {
			$role = strtoupper($m->role);
			$historyText .= "{$role}: {$m->content}\n";
		}
		if (!empty($entityHints['prompt'])) {
			$historyText .= "\nSYSTEM HINTS:\n" . implode("\n", $entityHints['prompt']) . "\n";
		}

		$prompt = <<<PROMPT
You are to produce ONE safe, read-only SQL statement for MySQL.
Constraints:
- Allowed verbs: SELECT, SHOW, DESCRIBE, EXPLAIN.
- No mutations, no multiple statements, no dangerous functions, no comments.
- Prefer simple joins and explicit columns. If aggregating, alias columns clearly.
- If no LIMIT is provided, add LIMIT {$maxRows}.
- CRITICAL: Use EXACT table names as shown in the schema below. Do not guess or abbreviate table names.
- If you need sales data, use 'sales_receipts' table, not 'sales'.
- If you need inventory data, use 'inventory_general' table, not 'inventory'.
- Always verify table names exist in the schema before using them.
- Do NOT use CREATE (including CREATE TEMPORARY TABLE or CREATE VIEW), DROP, INSERT, UPDATE, DELETE, REPLACE, TRUNCATE, ALTER, GRANT, REVOKE, SET, or file I/O (INFILE/OUTFILE/LOAD_FILE).
- If you need intermediate results, use subqueries, joins, or a CTE (WITH ...) within a single SELECT.

Database schema (compact):
{$schema}

Chat context:
{$historyText}

User request:
{$message->content}

Return only SQL. No markdown, no explanation.
PROMPT;

		try {
			$sql = $this->openAI->generateSql($prompt);
			
			// Debug: Log the SQL generated by AI
			Log::info('SQL generated by OpenAI:', ['sql' => $sql]);
			
			$sql = $this->sqlGuard->sanitize($sql);
			
			// Debug: Log the sanitized SQL
			Log::info('Sanitized SQL:', ['sql' => $sql]);
			// Apply entity-driven alias corrections first
			if (!empty($entityHints['replacements'])) {
				$old = $sql;
				foreach ($entityHints['replacements'] as $from => $to) {
					$pattern = '/\b' . preg_quote($from, '/') . '\b/i';
					$sql = preg_replace($pattern, (string)$to, $sql);
				}
				if ($old !== $sql) {
					Log::info('Applied entity replacements', ['before' => $old, 'after' => $sql]);
				}
			}

			// Validate schema usage before execution
			$sql = $this->applyAliasCorrections($sql);
			$sql = $this->validateSchema($sql);

			$result = $this->executeWithTimeout($sql, 15);

			$message->sql = $sql;
			$message->result = $this->truncateResult($result, $maxRows);
			$message->save();

			return ['ok' => true, 'sql' => $sql, 'rows' => $message->result];
		} catch (\Throwable $e) {
			$message->sql = $message->sql ?? null;
			$message->error = $e->getMessage();
			$message->save();
			return ['ok' => false, 'error' => $e->getMessage(), 'sql' => $message->sql];
		}
	}

	private function executeWithTimeout(string $sql, int $seconds): array
	{
		$seconds = max(1, min(60, $seconds));
		$driver = config('database.default');
		
		// Only set timeout for MySQL/MariaDB if the variable is supported
		if (in_array(config("database.connections.$driver.driver"), ['mysql','mariadb'], true)) {
			try {
				// Check if MAX_EXECUTION_TIME is supported
				DB::statement('SET SESSION MAX_EXECUTION_TIME = ?', [$seconds * 1000]);
			} catch (\Exception $e) {
				// If MAX_EXECUTION_TIME is not supported, just log it and continue
				Log::info('MAX_EXECUTION_TIME not supported, continuing without timeout setting');
			}
		}
		
		return DB::select($sql);
	}

	private function truncateResult(array $rows, int $maxRows): array
	{
		if (count($rows) <= $maxRows) return $rows;
		return array_slice($rows, 0, $maxRows);
	}

	private function validateSchema(string $sql): string
	{
		$attempts = 0;
		$maxAttempts = 2;
		do {
			try {
				DB::select('EXPLAIN ' . $sql);
				return $sql; // valid
			} catch (\Throwable $e) {
				$message = $e->getMessage();
				$unknownTable = null;
				$unknownColumn = null;
				if (preg_match('/Table\s+\'([^\']+)\'\s+doesn\'t\s+exist/i', $message, $m)) {
					$unknownTable = $m[1];
				} elseif (preg_match('/Unknown\s+column\s+\'([^\']+)\'/i', $message, $m)) {
					$unknownColumn = $m[1];
				}

				// Attempt small alias-based correction for common mistakes
				$aliasMap = [
					'branch_id' => 'branch',
					'created_at' => 'date',
				];
				if ($unknownColumn && $attempts < $maxAttempts) {
					// Strip table alias if present, e.g., sr.created_at -> created_at
					$bare = preg_replace('/^.*\./', '', $unknownColumn);
					$aliasKey = isset($aliasMap[$unknownColumn]) ? $unknownColumn : (isset($aliasMap[$bare]) ? $bare : null);
					if ($aliasKey !== null) {
						$replacement = $aliasMap[$aliasKey];
						$oldSql = $sql;
						// Replace both qualified and unqualified occurrences
						$colPattern = '/\b(?:[`\w]+\.)?' . preg_quote($bare, '/') . '\b/i';
						$sql = preg_replace($colPattern, $replacement, $sql);
						Log::info('Auto-corrected unknown column using alias map', ['from' => $unknownColumn, 'to' => $replacement, 'before' => $oldSql, 'after' => $sql]);
						$attempts++;
						continue; // retry EXPLAIN with corrected SQL
					}
				}

				// Provide suggestions if we cannot auto-correct
				if ($unknownTable) {
					$this->throwWithTableSuggestions($unknownTable, $message);
				}
				if ($unknownColumn) {
					$this->throwWithColumnSuggestions($unknownColumn, $sql, $message);
				}
				throw $e;
			}
		} while ($attempts <= $maxAttempts);
		return $sql;
	}

	private function applyAliasCorrections(string $sql): string
	{
		$aliasesConfig = config('nl2sql.column_aliases', []);
		if (empty($aliasesConfig)) return $sql;
		// Determine tables referenced
		$tables = $this->extractTableCandidates($sql);
		$map = $aliasesConfig['*'] ?? [];
		foreach ($tables as $t) {
			if (isset($aliasesConfig[$t])) {
				$map = array_merge($map, $aliasesConfig[$t]);
			}
		}
		if (empty($map)) return $sql;
		$before = $sql;
		foreach ($map as $alias => $actual) {
			$bare = preg_quote($alias, '/');
			$pattern = '/\b(?:[`\w]+\.)?' . $bare . '\b/i';
			$sql = preg_replace($pattern, $actual, $sql);
		}
		if ($before !== $sql) {
			Log::info('Applied table-aware alias corrections', ['before' => $before, 'after' => $sql]);
		}
		return $sql;
	}

	private function throwWithTableSuggestions(string $unknownTable, string $originalMessage): void
	{
		$connection = config('database.default');
		$database = config("database.connections.$connection.database");
		$rows = DB::select(
			"SELECT TABLE_NAME FROM information_schema.TABLES WHERE TABLE_SCHEMA = ? ORDER BY TABLE_NAME",
			[$database]
		);
		$tables = array_map(fn($r) => $r->TABLE_NAME, $rows);
		$suggestions = $this->closestMatches($unknownTable, $tables);
		$hint = empty($suggestions) ? '' : (' Suggestions: ' . implode(', ', array_slice($suggestions, 0, 5)) . '.');
		throw new \InvalidArgumentException("Unknown table '$unknownTable'." . $hint);
	}

	private function throwWithColumnSuggestions(string $unknownColumn, string $sql, string $originalMessage): void
	{
		$connection = config('database.default');
		$database = config("database.connections.$connection.database");
		// Try to infer table names referenced in the SQL
		$tables = $this->extractTableCandidates($sql);
		$columnMap = [];
		foreach ($tables as $t) {
			$cols = DB::select(
				"SELECT COLUMN_NAME FROM information_schema.COLUMNS WHERE TABLE_SCHEMA = ? AND TABLE_NAME = ?",
				[$database, $t]
			);
			$columnMap[$t] = array_map(fn($r) => $r->COLUMN_NAME, $cols);
		}
		$allColumns = array_values(array_unique(array_merge(...array_values($columnMap) ?: [[]])));
		$suggestions = $this->closestMatches($unknownColumn, $allColumns);
		$hint = empty($suggestions) ? '' : (' Did you mean: ' . implode(', ', array_slice($suggestions, 0, 5)) . '?');
		throw new \InvalidArgumentException("Unknown column '$unknownColumn'." . $hint);
	}

	private function extractTableCandidates(string $sql): array
	{
		$matches = [];
		$tables = [];
		if (preg_match_all('/\bFROM\s+([`\w\.]+)/i', $sql, $matches)) {
			$tables = array_merge($tables, array_map(fn($s) => trim($s, '`'), $matches[1]));
		}
		if (preg_match_all('/\bJOIN\s+([`\w\.]+)/i', $sql, $matches)) {
			$tables = array_merge($tables, array_map(fn($s) => trim($s, '`'), $matches[1]));
		}
		return array_values(array_unique($tables));
	}

	private function closestMatches(string $needle, array $haystack): array
	{
		$scored = [];
		foreach ($haystack as $item) {
			$scored[$item] = levenshtein(strtolower($needle), strtolower($item));
		}
		asort($scored);
		return array_keys(array_slice($scored, 0, 5, true));
	}

	private function resolveEntitiesFromHistory($history): array
	{
		$config = config('nl2sql.entities', []);
		if (empty($config)) return ['prompt' => [], 'replacements' => []];
		$text = '';
		foreach ($history as $m) {
			if ($m->role === 'user') $text .= ' ' . $m->content;
		}
		$promptHints = [];
		$replacements = [];
		foreach ($config as $rule) {
			if (empty($rule['detect_regex'])) continue;
			if (!preg_match($rule['detect_regex'], $text, $mm)) continue;
			$name = trim($mm[1]);
			// resolve id
			$id = $this->resolveEntityId($rule, $name);
			if ($id === null) continue;
			// prompt hint for the model
			$promptHints[] = strtoupper($rule['entity']) . ": name='" . $name . "' resolved_id=" . $id . ". Use " . ($rule['join_hint'] ?? '') . " or filter column " . implode(',', $rule['target_tables']) . ".";
			// add replacement into known target columns for downstream corrections
			if (!empty($rule['target_tables'])) {
				foreach ($rule['target_tables'] as $table => $column) {
					$replacements[$column] = $id;
				}
			}
		}
		return ['prompt' => $promptHints, 'replacements' => $replacements];
	}

	private function resolveEntityId(array $rule, string $name): ?int
	{
		// Try exact match first
		$params = [$name];
		$where = [];
		foreach ($rule['name_columns'] as $col) {
			$where[] = "$col = ?";
		}
		$sql = "SELECT " . $rule['id_column'] . " AS id FROM " . $rule['table'] . " WHERE (" . implode(' OR ', $where) . ") LIMIT 1";
		$row = DB::selectOne($sql, $params);
		if (!empty($row?->id)) return (int)$row->id;
		// Fallback to LIKE partial match
		$params = array_fill(0, count($rule['name_columns']), "%$name%");
		$where = [];
		foreach ($rule['name_columns'] as $col) {
			$where[] = "$col LIKE ?";
		}
		$sql = "SELECT " . $rule['id_column'] . " AS id FROM " . $rule['table'] . " WHERE (" . implode(' OR ', $where) . ") ORDER BY LENGTH(" . $rule['name_columns'][0] . ") ASC LIMIT 1";
		$row = DB::selectOne($sql, $params);
		return $row->id ?? null;
	}
}
